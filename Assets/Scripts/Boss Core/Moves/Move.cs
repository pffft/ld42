using System.Collections;
using System.Collections.Generic;
using UnityEngine;

using AI;
using Projectiles;
using AOEs;

namespace Moves
{
    public abstract class Move
    {
        /*
         * A relative difficulty parameter. 
         * 
         * This is from a scale of 0 - 10, where a "10" is the point where any person
         * would call the move "actual bullshit". That means that the move may guarantee
         * damage, might not have safespots, might be too fast, or all of the above.
         * 
         * Most moves that make it to the game should be at most an 8.
         * 
         * This can go above 10, but that's for testing purposes (or masochism).
         */
        public abstract float GetDifficulty();

        /*
         * What's the name of this Move?
         * 
         * The default value is the name of the class.
         */
        public virtual string GetName() {
            return GetType().Name;
        }

        /*
         * What does this Move do?
         * 
         * The default value is autogenerated from the provided AISequence.
         * You should override this method with a more descriptive bit of text.
         */
        public virtual string GetDescription() {
            return GetSequence().description;
        }

        /*
         * The actual AISequence that we're using.
         * 
         * This should be a "pure" sequence- without any delays before or after
         * the actual body, and without any teleporting (except as part of the
         * move itself). Those should be added in the respective methods.
         */
        public abstract AISequence GetSequence();

        /*
         * How long should we wait before we start the move?
         * 
         * This should give the player a chance to center themselves in preparation
         * for the attack. The general rule of thumb is to wait 0.25-0.50 seconds
         * before an attack; longer for harder attacks.
         */
        public virtual float GetBeforeDelay() 
        {
            return 0f;
        }

        /*
         * How long should we wait after the end of the move?
         * 
         * This should be just enough time for any AOEs or Projectiles to disappear
         * naturally, or any other spawns of this Move to be cleaned up.
         */
        public virtual float GetAfterDelay()
        {
            return 0f;
        }

        /*
         * Where should we teleport to before starting this move?
         * 
         * The default value is "null", indicating we pick a random position.
         * There are constants in "World.Arena"; specific positions can also
         * be provided.
         * 
         * If you don't teleport in your code, override DoesTeleportAtStart.
         */
        public virtual Vector3? GetStartTeleportPosition() {
            return null;
        }

        /*
         * Do we teleport at the start of the move?
         * 
         * Override this and return "false" if you don't want to teleport.
         */
        public virtual bool DoesTeleportAtStart() {
            return true;
        }

        // Returns a constructed sequence with the correct timings and movements applied.
        public AISequence GetFinalSequence()
        {
            return DoesTeleportAtStart()
                ? SequenceGenerators.Teleport(GetStartTeleportPosition())
                    .Wait(GetBeforeDelay())
                    .Then(GetSequence())
                    .Wait(GetAfterDelay())
                : AISequence
                    .Pause(GetBeforeDelay())
                    .Then(GetSequence())
                    .Wait(GetAfterDelay());
        }
    }
}
